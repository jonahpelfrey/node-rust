pub fn to_fixed(number: f64, places: i32) -> f64 {
    let base: f64 = 10.0;
    let power: f64 = places as f64;
    let divisor: f64 = base.powf(power);
    return ((number * divisor).round()) / divisor
}

pub fn subsidy_percent(coverage_level: f64) -> f64 {
	match (coverage_level * 100.0) as i32 {
		80 => 0.550,
		85 => 0.490,
		90 => 0.440,
		95 => 0.440,
		_ => 0.440
	}
}

pub fn calculate_simulated_price(draw: f64, sigma: f64, expected_price: f64) -> f64 {
    let a = {
        let x = norms_inv(draw, 0.0, 1.0) * sigma + expected_price.ln();
        to_fixed(x, 4)
    };

    let b = {
        let x = sigma.powi(2) * 0.5;
        to_fixed(x, 4)
    };

    let c = {
        let x = (a - b).exp();
        to_fixed(x, 4)
    };

    return c
}

pub fn norms_inv(p: f64, mu: f64, sigma: f64) -> f64 {
 
    if p <0.0 || p > 1.0 {
        println!("The probability p must satisfy 0 < p < 1");
    }

    if sigma < 0.0 {
        println!("The value of sigma must be positive");
    }

    if p == 0.0 {
        println!("-Infinity");
        return -std::f64::INFINITY
    }

    if p == 1.0 {
        println!("Infinity");
        return std::f64::INFINITY
    }

    if sigma == 0.0 {
        return mu
    }

    let mut r: f64;
    let mut val: f64;

    let q: f64 = p - 0.5;

    if q.abs() <= 0.425 {
        r = 0.180625 - q*q;
        val = q * (((((((r * 2509.0809287301226727 +
                          33430.575583588128105) * r + 67265.770927008700853) * r +
                        45921.953931549871457) * r + 13731.693765509461125) * r +
                      1971.5909503065514427) * r + 133.14166789178437745) * r +
                    3.387132872796366608)
               / (((((((r * 5226.495278852854561 +
                        28729.085735721942674) * r + 39307.89580009271061) * r +
                      21213.794301586595867) * r + 5394.1960214247511077) * r +
                    687.1870074920579083) * r + 42.313330701600911252) * r + 1.0);
    
    } else {
        
        if q > 0.0 {
            r = 1.0 - p;
        } else {
            r = p;
        }

        r = -r.ln();
        r = r.sqrt();

        if r <= 5.0 {
            r += -1.6;
            val = (((((((r * 7.7454501427834140764e-4 +
                       0.0227238449892691845833) * r + 0.24178072517745061177) *
                     r + 1.27045825245236838258) * r +
                    3.64784832476320460504) * r + 5.7694972214606914055) *
                  r + 4.6303378461565452959) * r +
                 1.42343711074968357734)
                / (((((((r *
                         1.05075007164441684324e-9 + 5.475938084995344946e-4) *
                        r + 0.0151986665636164571966) * r +
                       0.14810397642748007459) * r + 0.68976733498510000455) *
                     r + 1.6763848301838038494) * r +
                    2.05319162663775882187) * r + 1.0);

        } else {
            r += -5.0;
            val = (((((((r * 2.01033439929228813265e-7 +
                       2.71155556874348757815e-5) * r +
                      0.0012426609473880784386) * r + 0.026532189526576123093) *
                    r + 0.29656057182850489123) * r +
                   1.7848265399172913358) * r + 5.4637849111641143699) *
                 r + 6.6579046435011037772)
                / (((((((r *
                         2.04426310338993978564e-15 + 1.4215117583164458887e-7) *
                        r + 1.8463183175100546818e-5) * r +
                       7.868691311456132591e-4) * r + 0.0148753612908506148525)
                     * r + 0.13692988092273580531) * r +
                    0.59983220655588793769) * r + 1.0);
        }

        if q < 0.0
        {
            val = -val;
        }
    }

    return mu + sigma * val;

}